const fs = require('fs');
const firstline = require('firstline');
const { promisify } = require('util')

const readFileAsync = promisify(fs.readFile);
const openFileAsync = promisify(fs.open);
const writeFileAsync = promisify(fs.writeFile);
const appendFileAsync = promisify(fs.appendFile);

const secureString = "// This file is generated by xdepend"
const description = "//\n// Thanks for using my tool, if you find a bug or \n// you have a feature request, post it on the github page"

/**
 * Checks if file exists and then if it is secure
 * A file is secure if the first line of the file contains secureString
 * otherwise we assume you have a typo in your path
 *
 * @param filePath
 * @returns {Promise<unknown>} - resolves false if file does not exists, resolves true if file is secure, rejects if file is not secure
 */
function checkFileSecure(filePath) {
	return new Promise((resolve, reject) => {
		// check if path exists
		// use fs.open when reading afterwards - @see https://nodejs.org/api/fs.html#fs_fs_access_path_mode_callback
		// r+ opens file in read only mode, if it does not exist, then fs.open throws an error

		return fs.open(filePath, 'r+', async (err) => {
			if(err && err.code === 'ENOENT') {
				resolve(false); // File does not exist
			} else {

				// secureString / secureContent is used to make sure we alter the right file
				// we do not want to loose you data because of a typo in the path :)
				const fl = await firstline(filePath);
				if (fl !== secureString) {
					reject(new Error("Check the filepath we probably overwrite an existing file !!!"));
				} else {
					resolve(true); // File exists and is secure
				}
			}
		})
	})
}

/**
 * @param filePath
 * @returns {Promise<unknown>} - resolves true if file is removed, resolves false if file does not exist
 */
function removeOldFile(filePath) {
	// we check first if the file exists, then if the first line is secure
	// if both conditions are met, then we remove the file :)
	return new Promise( (resolve, reject) => {
		return checkFileSecure(filePath).then((exists) => {
			if(exists) {
				fs.unlink(filePath, (err) => {
					if (err) reject(err);
					resolve(true);
				});
			} else {
				resolve(false);
			}
		})
	});
}

/**
 * @param filePath
 * @param content
 * @returns {Promise<unknown>} - resolves true if file is written successfully
 */
function writeFile(filePath, content) {
	// secureString / secureContent is used to make sure we alter the right file
	// we do not want to loose you data because of a typo in the path :)
	return new Promise((resolve, reject) => {
		checkFileSecure(filePath).then(() => {
			const secureContent = `${secureString}\n${description}\n\n${content}`;
			fs.writeFile(filePath, secureContent, (err) => {
				if(err) reject(err);
				resolve( true);
			})
		}).catch((err) => {
			reject(err)
		});
	})
}

/**
 * @param filePath
 * @param content
 * @returns {Promise<unknown>} - resolves true if content is appended successfully
 */
function appendFile(filePath, content) {
	// secureString / secureContent is used to make sure we alter the right file
	// we do not want to loose you data because of a typo in the path :)
	return new Promise(async (resolve, reject) => {
		// const fl = await firstline(filePath);
		// if (fl !== secureString) {
		// 	reject(new Error("Check the filepath we probably overwrite an existing file !!!"));
		// }
		checkFileSecure(filePath).then(() => {
			const contentNewLine = `\n${content}`;
			fs.appendFile(filePath, contentNewLine, (err) => {
				if (err) reject(err);
				resolve(true);
			})
		}).catch((err) => {
			reject(err);
		})
	})
}

function readFile(filePath) {
	// Well, plain simple readfile function huh!?
	return new Promise((resolve, reject) => {
		fs.readFile(filePath, "utf8", (err, data) => {
			if (err) {
				reject(err);
			}

			resolve(data);
		});
	});
}

module.exports = { writeFile, readFile, removeOldFile, appendFile, checkFileSecure };
